# coding: utf-8

"""
    Together APIs

    The Together REST API. Please see https://docs.together.ai for more details.

    The version of the OpenAPI document: 2.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    StrictBool,
    StrictFloat,
    StrictInt,
    StrictStr,
    field_validator,
)
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from together.generated.models.chat_completion_request_function_call import (
    ChatCompletionRequestFunctionCall,
)
from together.generated.models.chat_completion_request_messages_inner import (
    ChatCompletionRequestMessagesInner,
)
from together.generated.models.chat_completion_request_model import (
    ChatCompletionRequestModel,
)
from together.generated.models.chat_completion_request_response_format import (
    ChatCompletionRequestResponseFormat,
)
from together.generated.models.chat_completion_request_tool_choice import (
    ChatCompletionRequestToolChoice,
)
from together.generated.models.tools_part import ToolsPart
from typing import Optional, Set
from typing_extensions import Self


class ChatCompletionRequest(BaseModel):
    """
    ChatCompletionRequest
    """  # noqa: E501

    messages: List[ChatCompletionRequestMessagesInner] = Field(
        description="A list of messages comprising the conversation so far."
    )
    model: ChatCompletionRequestModel
    max_tokens: Optional[StrictInt] = Field(
        default=None, description="The maximum number of tokens to generate."
    )
    stop: Optional[List[StrictStr]] = Field(
        default=None,
        description='A list of string sequences that will truncate (stop) inference text output. For example, "</s>" will stop generation as soon as the model generates the given token.',
    )
    temperature: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None,
        description="A decimal number from 0-1 that determines the degree of randomness in the response. A temperature less than 1 favors more correctness and is appropriate for question answering or summarization. A value closer to 1 introduces more randomness in the output.",
    )
    top_p: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None,
        description="A percentage (also called the nucleus parameter) that's used to dynamically adjust the number of choices for each predicted token based on the cumulative probabilities. It specifies a probability threshold below which all less likely tokens are filtered out. This technique helps maintain diversity and generate more fluent and natural-sounding text.",
    )
    top_k: Optional[StrictInt] = Field(
        default=None,
        description="An integer that's used to limit the number of choices for the next predicted word or token. It specifies the maximum number of tokens to consider at each step, based on their probability of occurrence. This technique helps to speed up the generation process and can improve the quality of the generated text by focusing on the most likely options.",
    )
    context_length_exceeded_behavior: Optional[StrictStr] = Field(
        default="error",
        description="Defined the behavior of the API when max_tokens exceed the maximum context length of the model. When set to 'error', API will return 400 with appropriate error message. When set to 'truncate', override the max_tokens with maximum context length of the model.",
    )
    repetition_penalty: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None,
        description="A number that controls the diversity of generated text by reducing the likelihood of repeated sequences. Higher values decrease repetition.",
    )
    stream: Optional[StrictBool] = Field(
        default=None,
        description="If true, stream tokens as Server-Sent Events as the model generates them instead of waiting for the full model response. The stream terminates with `data: [DONE]`. If false, return a single JSON object containing the results.",
    )
    logprobs: Optional[Annotated[int, Field(le=1, strict=True, ge=0)]] = Field(
        default=None,
        description="Determines the number of most likely tokens to return at each token position log probabilities to return.",
    )
    echo: Optional[StrictBool] = Field(
        default=None,
        description="If true, the response will contain the prompt. Can be used with `logprobs` to return prompt logprobs.",
    )
    n: Optional[Annotated[int, Field(le=128, strict=True, ge=1)]] = Field(
        default=None,
        description="The number of completions to generate for each prompt.",
    )
    min_p: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None,
        description="A number between 0 and 1 that can be used as an alternative to top_p and top-k.",
    )
    presence_penalty: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None,
        description="A number between -2.0 and 2.0 where a positive value increases the likelihood of a model talking about new topics.",
    )
    frequency_penalty: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None,
        description="A number between -2.0 and 2.0 where a positive value decreases the likelihood of repeating tokens that have already been mentioned.",
    )
    logit_bias: Optional[Dict[str, Union[StrictFloat, StrictInt]]] = Field(
        default=None,
        description="Adjusts the likelihood of specific tokens appearing in the generated output.",
    )
    seed: Optional[StrictInt] = Field(
        default=None, description="Seed value for reproducibility."
    )
    function_call: Optional[ChatCompletionRequestFunctionCall] = None
    response_format: Optional[ChatCompletionRequestResponseFormat] = None
    tools: Optional[List[ToolsPart]] = Field(
        default=None,
        description="A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.",
    )
    tool_choice: Optional[ChatCompletionRequestToolChoice] = None
    safety_model: Optional[StrictStr] = Field(
        default=None,
        description="The name of the moderation model used to validate tokens. Choose from the available moderation models found [here](https://docs.together.ai/docs/inference-models#moderation-models).",
    )
    __properties: ClassVar[List[str]] = [
        "messages",
        "model",
        "max_tokens",
        "stop",
        "temperature",
        "top_p",
        "top_k",
        "context_length_exceeded_behavior",
        "repetition_penalty",
        "stream",
        "logprobs",
        "echo",
        "n",
        "min_p",
        "presence_penalty",
        "frequency_penalty",
        "logit_bias",
        "seed",
        "function_call",
        "response_format",
        "tools",
        "tool_choice",
        "safety_model",
    ]

    @field_validator("context_length_exceeded_behavior")
    def context_length_exceeded_behavior_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(["truncate", "error"]):
            raise ValueError("must be one of enum values ('truncate', 'error')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ChatCompletionRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in messages (list)
        _items = []
        if self.messages:
            for _item_messages in self.messages:
                if _item_messages:
                    _items.append(_item_messages.to_dict())
            _dict["messages"] = _items
        # override the default output from pydantic by calling `to_dict()` of model
        if self.model:
            _dict["model"] = self.model.to_dict()
        # override the default output from pydantic by calling `to_dict()` of function_call
        if self.function_call:
            _dict["function_call"] = self.function_call.to_dict()
        # override the default output from pydantic by calling `to_dict()` of response_format
        if self.response_format:
            _dict["response_format"] = self.response_format.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in tools (list)
        _items = []
        if self.tools:
            for _item_tools in self.tools:
                if _item_tools:
                    _items.append(_item_tools.to_dict())
            _dict["tools"] = _items
        # override the default output from pydantic by calling `to_dict()` of tool_choice
        if self.tool_choice:
            _dict["tool_choice"] = self.tool_choice.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ChatCompletionRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "messages": (
                    [
                        ChatCompletionRequestMessagesInner.from_dict(_item)
                        for _item in obj["messages"]
                    ]
                    if obj.get("messages") is not None
                    else None
                ),
                "model": (
                    ChatCompletionRequestModel.from_dict(obj["model"])
                    if obj.get("model") is not None
                    else None
                ),
                "max_tokens": obj.get("max_tokens"),
                "stop": obj.get("stop"),
                "temperature": obj.get("temperature"),
                "top_p": obj.get("top_p"),
                "top_k": obj.get("top_k"),
                "context_length_exceeded_behavior": (
                    obj.get("context_length_exceeded_behavior")
                    if obj.get("context_length_exceeded_behavior") is not None
                    else "error"
                ),
                "repetition_penalty": obj.get("repetition_penalty"),
                "stream": obj.get("stream"),
                "logprobs": obj.get("logprobs"),
                "echo": obj.get("echo"),
                "n": obj.get("n"),
                "min_p": obj.get("min_p"),
                "presence_penalty": obj.get("presence_penalty"),
                "frequency_penalty": obj.get("frequency_penalty"),
                "logit_bias": obj.get("logit_bias"),
                "seed": obj.get("seed"),
                "function_call": (
                    ChatCompletionRequestFunctionCall.from_dict(obj["function_call"])
                    if obj.get("function_call") is not None
                    else None
                ),
                "response_format": (
                    ChatCompletionRequestResponseFormat.from_dict(
                        obj["response_format"]
                    )
                    if obj.get("response_format") is not None
                    else None
                ),
                "tools": (
                    [ToolsPart.from_dict(_item) for _item in obj["tools"]]
                    if obj.get("tools") is not None
                    else None
                ),
                "tool_choice": (
                    ChatCompletionRequestToolChoice.from_dict(obj["tool_choice"])
                    if obj.get("tool_choice") is not None
                    else None
                ),
                "safety_model": obj.get("safety_model"),
            }
        )
        return _obj
